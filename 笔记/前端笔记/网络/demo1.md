# 网络
------------------------------------------------

WWW(World Wide Web)

冯诺依曼计算机：  
运算器，存储器，控制器，输入设备，输出设备

IP地址：网络ID + 主机ID

域名经过DNS解析 为IP地址

127.0.0.1 访问本机
0.0.0.0  不知道IP地址，访问本机

五层网络模型：
应用层，运输层。，网络层，数据链路层，物理层

发送文件，大量数据要用POST
GET请求： GET /path?.. = ..&..=.. HTTP1.1 ,        请求的参数都在URL里 ，

POST请求：

请求：Request：
- 请求头
- 数据体
- 请求方式url版本协议

响应：Response：
- 响应头
- 数据体
- 协议版本   状态码 message


### Get和Post请求方式的区别：
1. 是基于什么前提的？如果什么前提都没有，不使用任何规范，只考虑语法和理论上的HTTP协议：
GET和POST几乎没有什么区别，只有名字不一样。
2. 如果是基于RFC规范的：
    - 理论上：get和post具有相同语法，但是有不同的语义。get是用来获取数据的，post是用来发送数据的，其它方面没有区别。
    - 实现上：各种浏览器，就是这个规范的实现者。常见的那些不同：get的数据在URL是可见的，post请求是不显示在URL中的。get请求是有长度限制的，post长度的无限的。get请求的数据可以收藏为书签，post请求到的不可以收藏为书签。get请求后，an后退按钮、刷新按钮无影响，post数据会被重新提交。get编码类型：application/x-www-form-url,post的编码类型有很多：encodeapplication/x-www-form-urlencoded    multipart/form-data。get的历史参数会被保留在浏览器里，post的不会保存在浏览器中。get值允许ASCII，post没有编码限制，允许发二进制。get与post相比get的安全性较差，因为所发的数据是URL的一部分。

### Cookie与Session

1. 如果我们⽤JS的变量来存数据，那么在⻚⾯关闭的时候，数据就消失了。

2. 保持登录状态是怎么做到的呢？

    按照正常的HTTP协议来说，是做不到的。
因为HTTP协议，上下⽂⽆关协议。

3. 所以说前端⻚⾯上，有可以持久化存储数据的东⻄。⼀旦登录成功，我就记载在这个⾥⾯。


Cookie是有限制的。

Cookie是存在浏览器⾥的，不是存在某个⻚⾯上的。是可以⻓期存储的。Cookie即使是保存在浏览器⾥，也是存放在不同的域名下的。

1. 初始状态：没有登录

2. 访问百度的登录，输⼊⽤户名，密码。

3. 如果⽤户名和密码是正确的。百度的后端会向这个域名下，设置⼀个Cookie。写⼊⽤户的基本信息（加密的）。

4. 以后每⼀次向百度发送请求，浏览器都会⾃动带上这些Cookie。

5. 服务端（后端）看到了带有ID的cookie，就可以解析这个加密的ID，来获取到这个⽤户本身的ID。

6. 如果能获取到本身的ID，那么就证明这个⽤户已经登录过了。所以后端可以继续保留⽤户的信息。



**缺点**：如果某个坏⼈，复制了我浏览器⾥的cookie，他就可以在他的电脑上登录我的账号了。

XSS注⼊攻击。浏览器 


#### 数据存在Session上也有缺点：

如果⽤户量⾮常⼤，上亿的⽤户。

在⽤户量很⼤的时候，服务器端很耗资源的。

因为后端可能不⽌⼀台服务器，⽤户的登录信息，⼀般只存在⼀台服务器上。

因为⽤户的登录操作，在哪台机器上执⾏的，就⼀般存在哪台机器上。

需要通过反向代理。（轮询，IP哈希。）

### B/S结构    C/S结构

Client/Server——Client只负责内容的展示，Server负责提供内容。

Browser/Server——Browser只负责内容的展示，Server负责提供内容。




⻚⾯的本质是什么？  
⻚⾯的本质就是⼀个字符串。带有HTML格式的字符串。

浏览器 向服务器 请求⼀个⻚⾯的本质是什么？

（1）www.baidu.com

（2）服务器接收到这个请求后，服务器想要把这个⻚⾯的内容（HTML格式的字符串）返回

给浏览器。

（3）⻚⾯的字符串存在哪⾥呢？存在HTML⽂件⾥。例如：index.html 

（4）服务器端要读取⽂件。

（5）将读取出来的内容返回给浏览器。

最后返回的是⼀个字符串，这个字符串的来源可能是⽂件，可能是缓存，可能来⾃于数据库。

服务器：严格的说，服务器是⼀台计算机，这台计算机，只提供服务。（不是⽤户⽤的）

但是，我们常说的这个服务器，指的是服务容器，不是服务器。

服务容器：是⼀个程序。程序可以监听⼀个端⼝。读取⽂件，并且返回。

如果我们想通过访问服务器（服务容器）的⽅式，来访问我们⾃⼰写的⻚⾯。

我们就得装⼀个服务容器的程序。

向后端发出请求：
1. 在浏览器中直接输入网址（无法用代码控制）
2. location.href = url; 可以发出网络请求，但是页面会发生跳转。（页面跳转）
3. 带有src属性的标签，请求是可以发出的，服务端是可以处理也是可以返回的，但是返回之后能否被应用，还要看浏览器。（页面无法处理返回结果）
4. 带有href属性的标签，请求是可以发出的，服务端是可以处理也是可以返回的，但是返回之后能否被应用，还要看浏览器。（页面无法处理返回结果）
5. 带有action属性的标签，例如form表单，也可以向后端发出请求。但是form表单发出请求之后，也会页面跳转。（页面会跳转）
6. ajax请求

**要素；请求方式，url**


### 跨域访问资源

哪些东⻄属于资源？

js⽂件算吗？js⽂件肯定是算资源的，但是js⽂件是允许被跨域请求的。

css⽂件，jpg,png等。src属性的资源都是可以被跨域请求的。href资源⼤部分都是可以被跨域请求的。

##### 哪些资源算跨域请求的资源？

1. 后端接⼝的数据。

2. 其它域的cookie 

3. 其它域的缓存


##### 什么是其它的域？怎么样算跨域？

⻚⾯本身：有协议（http/https）,域名，端⼝

要请求的数据：http://www.baidu.com:80

协议，域名，端⼝这三个，有任意⼀个不⼀样就算跨域。

跨域这个⾏为，发⽣在哪⾥？

答案：

1. 即使跨域了（协议，域名，端⼝号有不⼀样的），请求也可以发出。

2. 服务器端也是可以接收的。

3. 服务器端也是可以正常处理的。

4. 服务器端也是可以正常返回数据。

5. 浏览器也能接收到这些数据。

6. 接收到之后，发现当前⻚⾯的域和请求的域不同，所以判定为跨域。

7. 我们的代码在这等着结果呢，但是因为浏览器判定跨域了，不会把结果传递给我们的代码。


虽然跨域了，但是我们依然需要这个数据，怎么办？

解决跨域问题：

1. 后端（别⼈家的）配合我们进⾏跨域。

 pan.baidu.com ——> zhidao.baidu.com

    1）JSONP（正常的情况，返回的数据都是JSON格式。JSONP是⼀种特殊的格式。）
    2）后端设置Access-Control-Allow-Origin属性以⽀持跨域。（聊天机器⼈课讲，因为需要nodejs）

2. 后端不配合我们进⾏跨域。

    3）iframe（只能显示，不能控制）

    4）通过后端代理（⾃⼰的后端）（后⾯聊天机器⼈讲，因为需要nodejs）


readyState ：
状态4代表请求完成，已经接收到数据

jsonp跨域，只能使用get方法，如果我们设置的是post方法，jQuery会自动转为get方法

jQuery会先判断是否同源，如果同源，那么设置的是get就是get，设置的是post就是post
不是同源的话，就都改为get(跨域)

script标签，虽然可以引用其他域的资源，浏览器不限制，但是，浏览器会将返回的内容当做js代码执行。

jsonp原理：
前端：
1. 判断请求与当前页面的域是是否同源，如果同源则发送Ajax，没有跨域
2. 如果不同源，生成一个script标签
3. 生成一个随机的callback名字
4. 设置script标签的src设置为要请求的接口
5. 将callback作为参数拼接在后面
后端：
6. 后端接收到请求后，开始准备要返回的数据
7. 后端拼接数据，将要返回的数据用callback的值和括号包裹起来。
8. 将内容返回

9. 浏览器接收到内容，会当做js代码来执行
10. 从而执行方法，这样我们就接收到了后端返回给我们的对象。